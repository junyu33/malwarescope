import angr
import angrutils
import sys
import pdb
import copy

def flatten_list_and_uniq(nested_list):
    flat_list = []
    for element in nested_list:
        if isinstance(element, list):
            # If element is a list, extend flat_list with the flattened element
            flat_list.extend(flatten_list_and_uniq(element))
        else:
            # If element is not a list, append it to flat_list
            flat_list.append(element)

    new_list = []
    for i in flat_list:
        duplicate = 0
        for j in new_list:
            if i.addr == j.addr:
                duplicate = 1

        if duplicate == 0:
            new_list.append(i)
            
    return new_list

def get_min_depth(func, trace):
    if func.name == 'start' or func.name == '_start':
        return 1
    else:
        min_depth = 1000000
        for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
            if caller in cfg.kb.functions and cfg.kb.functions[caller] not in trace:
                trace.append(cfg.kb.functions[caller])
                min_depth = min(min_depth, get_min_depth(cfg.kb.functions[caller], trace) + 1)
                trace.remove(cfg.kb.functions[caller])
        return min_depth

def get_intersection(list1, list2):
    intersection = []
    for i in list1:
        for j in list2:
            if i.addr == j.addr:
                intersection.append(i)
    return intersection


def get_LCA(func1, func2):
    ancestor_list1 = ancestor(func1)
    ancestor_list2 = ancestor(func2)

    for ans in ancestor_list1:
        if ans.addr == func2.addr:
            return func2
    for ans in ancestor_list2:
        if ans.addr == func1.addr:
            return func1

    while get_intersection(ancestor_list1, ancestor_list2) == []:
        new_list1 = copy.deepcopy(ancestor_list1)
        new_list2 = copy.deepcopy(ancestor_list2)

        for ans in ancestor_list1:
            new_list1.extend(ancestor(ans))

        for ans in ancestor_list2:
            new_list2.extend(ancestor(ans))

        if new_list1 == ancestor_list1 and new_list2 == ancestor_list2:
            return None

        ancestor_list1 = flatten_list_and_uniq(new_list1)
        ancestor_list2 = flatten_list_and_uniq(new_list2)
        #print(ancestor_list1)
        #print(ancestor_list2)

    intersection = get_intersection(ancestor_list1, ancestor_list2)

    maxdepth = 0
    result = None
    for i in intersection:
        if get_min_depth(i, [func1, func2]) > maxdepth:
            maxdepth = get_min_depth(i, [func1, func2])
            result = i

    return result

def get_subfunc_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return func

    ancestor_list1 = ancestor(func)
    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return func

    while True:
        new_list = copy.deepcopy(ancestor_list1)
        for ans in ancestor_list1:
            new_list.extend(ancestor(ans))
        ancestor_list1 = flatten_list_and_uniq(new_list)

        for ans in ancestor_list1:
            for i in ancestor(ans):
                if i.addr == LCA.addr:
                    return ans

def get_trace_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return (True, [func])

    ancestor_list1 = ancestor(func)
    if ancestor_list1 == []:
        return (False, [])

    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return (True, [func, ans]) 

    for ans in ancestor_list1:
        res = [func]
        (ok, trace) = get_trace_from_LCA(LCA, ans) 
        if ok:
            res.extend(trace)
            return (True, res)

    # suppress error
    return (False, [])


def ancestor(func):
    result = []
    #try:
    for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
        if caller in cfg.kb.functions:
            result.append(cfg.kb.functions[caller])
    #except AttributeError:
    #    print(func)
    #    exit(0)
    return result


def findnodebyaddr(myaddr):
    fixed = fix_func_addr(myaddr)
    for addr, func in cfg.kb.functions.items():
        if addr == fixed:
            return func

def fix_func_addr(addr):
    for i in range(tot_func - 1):
        if g_addr[i] <= addr < g_addr[i+1]:
            return g_addr[i]

proj = angr.Project(sys.argv[1], load_options={'auto_load_libs': False})

cfg = proj.analyses.CFGFast()

g_func = []
g_addr = []

tot_func = 0
for addr, func in cfg.kb.functions.items():
    # print(func.name, hex(addr))
    g_func.append(func.name), g_addr.append(addr)
    tot_func += 1

addrA = fix_func_addr(int(sys.argv[2], 16))
addrB = fix_func_addr(int(sys.argv[3], 16))

funcA = findnodebyaddr(addrA)
funcB = findnodebyaddr(addrB)

lca = get_LCA(funcA, funcB)
if lca != None:
    print(hex(lca.addr))
    print(get_trace_from_LCA(lca, funcA))
    #pdb.set_trace()
    print(get_trace_from_LCA(lca, funcB))
else:
    print("None")
