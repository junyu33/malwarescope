import angr
import claripy
import sys
import pdb

def main(binary_path):
    def ancestor(func):
        result = []
        #try:
        for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
            if caller in cfg.kb.functions:
                result.append(cfg.kb.functions[caller])
        #except AttributeError:
        #    print(func)
        #    exit(0)
        return result

    def fix_func_addr(addr):
        for i in range(tot_func - 1):
            if g_addr[i] <= addr < g_addr[i+1]:
                return g_addr[i]


    def findnodebyaddr(myaddr):
        fixed = fix_func_addr(myaddr)
        for addr, func in cfg.kb.functions.items():
            if addr == fixed:
                return func
    # Load the binary
    proj = angr.Project(binary_path, load_options={'auto_load_libs': False})
    
    # Get a CFG (Control Flow Graph) to help identify functions
    cfg = proj.analyses.CFGFast()

    g_func = []
    g_addr = []

    tot_func = 0

    # Iterate through all the functions found by CFG
    for addr, func in cfg.kb.functions.items():
        g_func.append(func.name), g_addr.append(addr)
        tot_func += 1
        print(f"Function Name: {func.name}, Virtual Address: {hex(addr)}")

    pdb.set_trace()
    # Optionally, you can explore more about each function
    # such as its endpoints, blocks, etc.

if __name__ == "__main__":
    binary_path = sys.argv[1]  # Change this to your binary's path
    main(binary_path)

