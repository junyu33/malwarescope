import angr
import angrutils
import sys
import pdb
import copy
import re, ast


def flatten_list_and_uniq(nested_list):
    flat_list = []
    for element in nested_list:
        if isinstance(element, list):
            # If element is a list, extend flat_list with the flattened element
            flat_list.extend(flatten_list_and_uniq(element))
        else:
            # If element is not a list, append it to flat_list
            flat_list.append(element)

    new_list = []
    for i in flat_list:
        duplicate = 0
        for j in new_list:
            if i.addr == j.addr:
                duplicate = 1

        if duplicate == 0:
            new_list.append(i)
            
    return new_list

def get_min_depth(func, trace):
    if func.name == 'start' or func.name == '_start':
        return 1
    else:
        min_depth = 1000000
        for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
            if caller in cfg.kb.functions and cfg.kb.functions[caller] not in trace:
                trace.append(cfg.kb.functions[caller])
                min_depth = min(min_depth, get_min_depth(cfg.kb.functions[caller], trace) + 1)
                trace.remove(cfg.kb.functions[caller])
        return min_depth

def get_intersection(list1, list2):
    intersection = []
    for i in list1:
        for j in list2:
            if i.addr == j.addr:
                intersection.append(i)
    return intersection


def get_LCA(func1, func2):
    ancestor_list1 = ancestor(func1)
    ancestor_list2 = ancestor(func2)

    for ans in ancestor_list1:
        if ans.addr == func2.addr:
            return func2
    for ans in ancestor_list2:
        if ans.addr == func1.addr:
            return func1

    while get_intersection(ancestor_list1, ancestor_list2) == []:
        new_list1 = copy.deepcopy(ancestor_list1)
        new_list2 = copy.deepcopy(ancestor_list2)

        for ans in ancestor_list1:
            new_list1.extend(ancestor(ans))

        for ans in ancestor_list2:
            new_list2.extend(ancestor(ans))

        if new_list1 == ancestor_list1 and new_list2 == ancestor_list2:
            return None

        ancestor_list1 = flatten_list_and_uniq(new_list1)
        ancestor_list2 = flatten_list_and_uniq(new_list2)
        #print(ancestor_list1)
        #print(ancestor_list2)

    intersection = get_intersection(ancestor_list1, ancestor_list2)

    maxdepth = 0
    result = None
    for i in intersection:
        if get_min_depth(i, [func1, func2]) > maxdepth:
            maxdepth = get_min_depth(i, [func1, func2])
            result = i

    return result

def get_subfunc_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return func

    ancestor_list1 = ancestor(func)
    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return func

    while True:
        new_list = copy.deepcopy(ancestor_list1)
        for ans in ancestor_list1:
            new_list.extend(ancestor(ans))
        ancestor_list1 = flatten_list_and_uniq(new_list)

        for ans in ancestor_list1:
            for i in ancestor(ans):
                if i.addr == LCA.addr:
                    return ans

def get_trace_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return (True, [func])

    ancestor_list1 = ancestor(func)
    if ancestor_list1 == []:
        return (False, [])

    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return (True, [func, ans]) 

    for ans in ancestor_list1:
        res = [func]
        (ok, trace) = get_trace_from_LCA(LCA, ans) 
        if ok:
            res.extend(trace)
            return (True, res)

    # suppress error
    return (False, [])


def ancestor(func):
    result = []
    #try:
    for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
        if caller in cfg.kb.functions:
            result.append(cfg.kb.functions[caller])
    #except AttributeError:
    #    print(func)
    #    exit(0)
    return result


def findnodebyaddr(myaddr):
    fixed = fix_func_addr(myaddr)
    for addr, func in cfg.kb.functions.items():
        if addr == fixed:
            return func

def fix_func_addr(addr):
    for i in range(tot_func - 1):
        if g_addr[i] <= addr < g_addr[i+1]:
            return g_addr[i]

def get_idx_from_name(name):
    txtname = name + ".txt"
    line_index = 0

    with open('map_from_line_to_file.txt', 'r') as f:
        lines = f.readlines()
        for line in lines:
            line_index += 1
            if txtname in line:
                match = re.search(r'\{.*\}', line)
                if match is None:
                    return -1, []
                dict_str = match.group(0)
                return line_index, list(ast.literal_eval(dict_str))

    return -1, []

def read_specific_line(file_path, line_number):
    with open(file_path, 'r') as file:
        for line in file:
            line_number -= 1
            if line_number == 0:
                return ast.literal_eval(line)
    return []

if __name__ == "__main__":
    # initialize
    proj = angr.Project(sys.argv[1], load_options={'auto_load_libs': False})

    cfg = proj.analyses.CFGFast()

    g_func = []
    g_addr = []

    tot_func = 0
    for addr, func in cfg.kb.functions.items():
        # print(func.name, hex(addr))
        g_func.append(func.name), g_addr.append(addr)
        tot_func += 1

    # get the lab ttps
    basename = sys.argv[1].split('/')[-1]
    line_idx, lab_ttp_list = get_idx_from_name(basename)

    if line_idx == -1:
        print("Not matching in map_from_line_to_file.txt")
        exit(0)

    # get real_ttp
    real_ttp = read_specific_line('ttp_one_file_per_line_new.txt', line_idx)

    # get the intersection
    intersection = list(set(lab_ttp_list) & set(real_ttp))

    if len(intersection) == 0:
        print("No intersection")
        exit(0)
    if len(intersection) == 1:
        # TODO
        print("Only one intersection")
        exit(0)
    if len(intersection) == 2:
        print(intersection[0])
        print(intersection[1])
        exit(0)


        addrA = get_evalnode_from_stacktrace(intersection[0])
        addrB = get_evalnode_from_stacktrace(intersection[1])

        #addrA = fix_func_addr(int(sys.argv[2], 16))
        #addrB = fix_func_addr(int(sys.argv[3], 16))

        funcA = findnodebyaddr(addrA)
        funcB = findnodebyaddr(addrB)

        lca = get_LCA(funcA, funcB)
        if lca != None:
            print(hex(lca.addr))
            print(get_trace_from_LCA(lca, funcA))
            #pdb.set_trace()
            print(get_trace_from_LCA(lca, funcB))
        else:
            print("None")
    else:
        print("More than two intersections")
        exit(0)
